diff --git a/src/Strappy/Planner.hs b/src/Strappy/Planner.hs
index f30def5..fbd575c 100644
--- a/src/Strappy/Planner.hs
+++ b/src/Strappy/Planner.hs
@@ -8,8 +8,7 @@ import Strappy.Library
 import Strappy.Type
 import Strappy.Task
 import Strappy.Utils
-  
-import Strappy.Library 
+import Strappy.Library
 import Strappy.LPCompress
 import Strappy.Config
 
@@ -21,7 +20,6 @@ import qualified Data.Map as Map
 import Data.List
 import Data.Maybe
 import Data.IORef
-
 import Data.Function
 
 
@@ -31,8 +29,7 @@ data PlanTask = PlanTask { ptName :: String,
                            ptSeed :: Expr     -- ^ Initial plan, such as an empty list, or the identity function
                          }
 
-mcmcPlan :: MonadRandom m =>
-            Expr -> -- ^ Initial plan, such as the empty list, or the identity function
+mcmcPlan :: Expr -> -- ^ Initial plan, such as the empty list, or the identity function
             [(Expr, Double)] -> -- ^ Distribution over expressions drawn from the grammar
             (Expr -> IO Double) -> -- ^ Log Likelihood function
             Int -> -- ^ length of the plan
@@ -96,47 +93,31 @@ doEMPlan fname tasks isHarderThan lambda pseudocounts frontierSize numPlans plan
   -- For each task, do greedy stochastic search to get candidate plans
   -- Each task records all of the programs used in successful plans, as well as the associated rewards
   -- These are normalized to get a distribution over plans, which gives weights for the MDL's of the programs
--- <<<<<<< HEAD
-
---  normalizedRewards <- forM tasks $ \tsk@PlanTask {ptLogLikelihood = likelihood, ptSeed = seed, ptType = tp, ptName = nm} -> do
---    -- Check to see we haven't failed on an easier task.
---    -- If so, we can bail on this one.
---    previousFailures <- readIORef taskFailures
---    if any (isHarderThan tsk) previousFailures
---      then putStrLn ("Skipping task " ++ nm) >> return []
---      else do
---      let frontier = snd $ fromJust $ find ((==tp) . fst) frontiers
---      (logPartitionFunction, programLogRewards, anyHit, anyPartial, newProgs) <- do
---        rnds <- replicateM numPlans $ replicateM planLen $ getRandomR (0, 1)
---        planResults <- flip Parallel.mapM rnds $ mcmcPlan seed frontier likelihood planLen
---        return $ foldl (\ (logZ, rewards, hit, part, newProgs) (logZ', rewards', hit', newProgs') ->
---                         (logSumExp logZ logZ', rewards++rewards', hit||hit', part||(not (null rewards')), nub $ newProgs++newProgs'))
---                       (log 0, [], False, False, []) planResults
---      when anyHit $ do
---        when verbose $ putStrLn $ "Hit " ++ nm
---        modifyIORef numHitRef (+1)
---      when (not anyPartial) $ modifyIORef taskFailures (tsk:)
---      when (verbose && (not anyHit) && (not anyPartial)) $ putStrLn $ "Missed " ++ nm
---      when ((not anyHit) && anyPartial) $ do
---        when verbose $ putStrLn $ "Got partial credit for " ++ nm
---        modifyIORef numPartialRef (+1)
---      modifyIORef programsPerTask $ \progs -> progs ++ [(nm, newProgs)]
---      -- normalize rewards
---      return $ map (\(e, r) -> (e, exp (r - logPartitionFunction))) programLogRewards
--- =======
-  normalizedRewards <- forM tasks $ \PlanTask {ptLogLikelihood = likelihood, ptSeed = seed, ptType = tp, ptName = nm} -> do
-    let frontier = snd $ fromJust $ find ((==tp) . fst) frontiers
-    (logPartitionFunction, programLogRewards, anyHit) <-
-      foldM (\ (logZ, rewards, hit) _ -> mcmcPlan seed frontier likelihood planLen >>=
-                                 \(logZ', rewards', hit') -> return (logSumExp logZ logZ', rewards++rewards', hit||hit'))
-            (log 0.0, [], False) [1..numPlans]
-    when anyHit $ do
-      when verbose $ putStrLn $ "Hit " ++ nm
-      modifyIORef numHitRef (+1)
-    when (verbose && (not anyHit)) $ putStrLn $ "Missed " ++ nm
-    -- normalize rewards
-    return $ map (\(e, r) -> (e, exp (r - logPartitionFunction))) programLogRewards
--- >>>>>>> parent of a93e2f8... Changes to allow IO parallelism.
+  normalizedRewards <- forM tasks $ \tsk@PlanTask {ptLogLikelihood = likelihood, ptSeed = seed, ptType = tp, ptName = nm} -> do
+    -- Check to see we haven't failed on an easier task.
+    -- If so, we can bail on this one.
+    previousFailures <- readIORef taskFailures
+    if any (isHarderThan tsk) previousFailures
+      then putStrLn ("Skipping task " ++ nm) >> return []
+      else do
+      let frontier = snd $ fromJust $ find ((==tp) . fst) frontiers
+      (logPartitionFunction, programLogRewards, anyHit, anyPartial, newProgs) <- do
+        rnds <- replicateM numPlans $ replicateM planLen $ getRandomR (0, 1)
+        planResults <- flip Parallel.mapM rnds $ mcmcPlan seed frontier likelihood planLen
+        return $ foldl (\ (logZ, rewards, hit, part, newProgs) (logZ', rewards', hit', newProgs') ->
+                         (logSumExp logZ logZ', rewards++rewards', hit||hit', part||(not (null rewards')), nub $ newProgs++newProgs'))
+                       (log 0, [], False, False, []) planResults
+      when anyHit $ do
+        when verbose $ putStrLn $ "Hit " ++ nm
+        modifyIORef numHitRef (+1)
+      when (not anyPartial) $ modifyIORef taskFailures (tsk:)
+      when (verbose && (not anyHit) && (not anyPartial)) $ putStrLn $ "Missed " ++ nm
+      when ((not anyHit) && anyPartial) $ do
+        when verbose $ putStrLn $ "Got partial credit for " ++ nm
+        modifyIORef numPartialRef (+1)
+      modifyIORef programsPerTask $ \progs -> progs ++ [(nm, newProgs)]
+      -- normalize rewards
+      return $ map (\(e, r) -> (e, exp (r - logPartitionFunction))) programLogRewards
   numHit <- readIORef numHitRef
   putStrLn $ "Hit " ++ show numHit ++ "/" ++ show (length tasks) ++ " tasks."
   -- Show number of unique programs
@@ -166,4 +147,4 @@ saveBestPlan fname plans =
                EQ -> compare w w'
                c -> c
            (bestPlan, bestW, bestLL) = maximumBy compareProgs progs
-       in nm ++ "\t" ++ show bestPlan ++ "\t" ++ show bestLL
+       in nm ++ "\t" ++ show bestPlan ++ "\t" ++ show bestLL
\ No newline at end of file
